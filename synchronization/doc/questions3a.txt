1 - Χρησιμοποιήστε το παρεχόμενο Makefile για να μεταγλωττίσετε και να τρέξετε το πρόγραμμα. Τι παρατηρείτε? Γιατί?
Καταρχήν παρατηρούμε ότι κατά την μεταγλώττιση του simplesync.c δημιουργούνται 2 εκτελέσιμα, το simplesync-atomic και το simplesync-mutex.
Επίσης όταν τρέχουμε οποιαδήποτε απο τις δυο εκδοχές του παίρνουμε ως αποτέλεσμα != 0. Το οποίο είναι λάθος διότι αρχικοποιούμε από το 0 κάνουμε increment ως φορές κάνουμε decrement.
Αυτό συμβαίνει διότι η εντολή ++*ip; σε assembly μεταφράζεται σε πάνω απο 1 εντολή.
Έτσι ο scheduler μπορεί να αποφασίσει να κάνει context switch χωρίς να ολοκληρωθεί πλήρως η εντολή ++*ip, και θα ξεμπλοκάρει άλλα threads που περιμένουν να εκτελέσουν την --*ip;.
Όμως η τιμή της *ip δεν έχει ανανεωθεί ακόμη από την πρώτη εντολή ++*ip πράγμα που οδηγεί σε διαφορετικό αποτέλεσμα.
 
2 - Μελετήστε πως παράγονται δύο διαφορετικά εκτελέσιμα simplesync-atomic, simplesync-mutex από το ίδιο αρχείο πηγαίου κώδικα simplesync.c
Το Makefile περιέχει το Preprocessor Option: -Dmacro[=defn]. Έτσι με το -DSYNC_ATOMIC κάνουμε define το macro SYNC_ATOMIC, ενώ με το -DSYNC_MUTEX το macro SYNC_MUTEX.
Αυτό στον κώδικα μας βάζει σε διαφορετικό branch του if και έτσι κάνουμε χρήση και mutexes και atomic ops.
Ερωτήσεις----------------------------------------------------------------------------------------------------- 
1 - Χρησιμοποιήστε την εντολή time(1) για να μετρήσετε το χρόνο εκτέλεσης των εκτελέσιμων.
Πώς συγκρίνεται ο χρόνος εκτέλεσης των εκτελέσιμων που εκτελούν συγχρονισμό, σε σχέση με το χρόνο εκτέλεσης του αρχικού προγράμματος χωρίς συγχρονισμό?Γιατί?

NO SYNC:        simplesync ~ 0.05s
SYNC:           simplesync-atomic ~ 0.53s
                simplesync-mutex ~ 1.31s

Ο χρόνος χωρίς συγχρονισμό είναι σημαντικά μικρότερος απ' ότι με συγχρονισμό.Στην περίπτωση των mutexes τα threads, εκτός απο τις εντολές στο critical sections πρέπει να εκτελέσουν και οποιαδήποτε εντολή έχει σχέση με το mutexing (π.χ. lock/unlock) και επιπλέον μόνο ένα thread μπορεί να εκτελέσει τις εντολές του critical section κάθε φορά.
Στην περίπτωση των atomic ops η καθυστέρηση δημιουργείται διότι αυτές οι εντολές παρεμβαίνουν σε θέματα όπως compiler optimization,pipelining.

2 - Ποιά μέθοδος συγχρονισμού είναι γρηγορότερη, η χρήση ατομικών λειτουργιών ή η χρήση των POSIX mutexes?Γιατι?

Γρηγορότερη είναι η μέθοδος των atomic ops διότι ,αν και όπως αναφέρθηκε παραπάνω προσπερνάει διάφορα optimizations στην εκτέλεση, δεν περιέχει κλειδώματα. Οπότε όλο το πρόγραμμα έχει κάποια πρόοδο.

3 - Σε ποιές εντολές του επεξεργαστή μεταφράζεται η χρήση ατομικών λειτουργιών του GCC στην αρχιτεκτονική για την οποία μεταγλωττίζετε?

lock addl $1, (%rbx) __sync_add_and_fetch

lock subl $1, (%rbx) __sync_sub_and_fetch

4 - Σε ποιές εντολές μεταφράζεται η χρήση POSIX mutexes στην αρχιτεκτονική για την οποία μεταγλωττίζετε?Παραθέστε παράδειγμα μεταγλώττισης λειτουργίας pthread_mutex_lock() σε Assembly, όπως στο προηγούμενο ερώτημα.

pthread_mutex_lock(): movq %rbp, %rdi
call pthread_mutex_lock@PLT

pthread_mutex_unlock(): call pthread_mutex_unlock@PLT
